package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"strconv"
	"strings"

	"golang.org/x/tools/imports"
)

func main() {
	log.SetPrefix("unroller: ")
	log.SetFlags(0)
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	var inPath, outPath string
	flag.StringVar(&inPath, "f", getEnv("GOFILE", "-"), "input file path")
	flag.StringVar(&outPath, "o", "", "output file path")
	flag.Parse()

	if outPath == "" {
		if inPath == "-" {
			flag.Usage()
			return fmt.Errorf("-o is required")
		}
		outPath = strings.TrimSuffix(inPath, ".go") + "_unrolled.go"
	}

	fileSet := token.NewFileSet()
	astFile, err := parser.ParseFile(fileSet, inPath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parse go file: %w", err)
	}
	commentMap := ast.NewCommentMap(fileSet, astFile, astFile.Comments)

	var buf bytes.Buffer
	decls := astFile.Decls

	astFile.Decls = nil
	astFile.Comments = nil

	if err := printer.Fprint(&buf, token.NewFileSet(), astFile); err != nil {
		return fmt.Errorf("write generated file: %w", err)
	}

	for _, decl := range decls {
		funcDecl, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}
		var unrolled ast.BlockStmt
		for i, stmt := range funcDecl.Body.List {
			forStmt, ok := stmt.(*ast.ForStmt)
			if !ok {
				if len(unrolled.List) > 0 {
					unrolled.List = append(unrolled.List, stmt)
				}
				continue
			}
			commentGroups, ok := commentMap[forStmt]
			if !ok {
				continue
			}
			if isUnrollTarget(commentGroups) {
				cr, err := toConstantRange(forStmt)
				if err != nil {
					return err
				}
				if len(unrolled.List) == 0 {
					unrolled.List = append(unrolled.List, funcDecl.Body.List[:i]...)
				}
				for x := cr.Init(); !cr.End(x); x = cr.Next(x) {
					unrolled.List = append(unrolled.List, &ast.BlockStmt{
						List: append([]ast.Stmt{
							&ast.DeclStmt{
								Decl: &ast.GenDecl{Tok: token.CONST, Specs: []ast.Spec{
									&ast.ValueSpec{
										Names:  []*ast.Ident{ast.NewIdent(cr.name)},
										Values: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(x)}},
									},
								}},
							},
						}, forStmt.Body.List...),
					})
				}
			} else if max, ok := isFallthroughTarget(commentGroups); ok {
				dr, err := toDynamicRange(forStmt, max)
				if err != nil {
					return err
				}
				if len(unrolled.List) == 0 {
					unrolled.List = append(unrolled.List, funcDecl.Body.List[:i]...)
				}
				var casesBlock ast.BlockStmt
				for i := 0; i < dr.max; i++ {
					casesBlock.List = append(casesBlock.List, &ast.CaseClause{
						List: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(dr.max - i)}},
						Body: []ast.Stmt{
							forStmt.Body,
							forStmt.Post,
							&ast.BranchStmt{Tok: token.FALLTHROUGH},
						},
					})
				}
				casesBlock.List = append(casesBlock.List, &ast.CaseClause{
					List: []ast.Expr{&ast.BasicLit{Kind: token.INT, Value: "0"}},
				})
				unrolled.List = append(unrolled.List, &ast.SwitchStmt{
					Init: forStmt.Init,
					Tag:  forStmt.Cond.(*ast.BinaryExpr).Y,
					Body: &casesBlock,
				})
			}
		}
		if len(unrolled.List) > 0 {
			original := funcDecl.Name.Name
			funcDecl.Name.Name += "Unrolled"
			funcDecl.Body = &unrolled

			fmt.Fprintf(&buf, "// %s is the unrolled version of %s\n", funcDecl.Name.Name, original)
			if err := printer.Fprint(&buf, token.NewFileSet(), funcDecl); err != nil {
				return fmt.Errorf("write generated file: %w", err)
			}
			buf.WriteString("\n\n")
		}
	}

	b, err := imports.Process(outPath, buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("process imports: %w", err)
	}
	f, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Fprintln(f, "// Code generated by unroller. DO NOT EDIT.")
	if _, err := f.Write(b); err != nil {
		return fmt.Errorf("write generated file: %w", err)
	}
	if err := f.Close(); err != nil {
		return fmt.Errorf("close generated file: %w", err)
	}
	return nil
}

func getEnv(key string, defaultValue string) string {
	v := os.Getenv(key)
	if v != "" {
		return v
	} else {
		return defaultValue
	}
}

func isUnrollTarget(cgs []*ast.CommentGroup) bool {
	for _, cg := range cgs {
		for _, c := range cg.List {
			if c.Text == "// UNROLL" {
				return true
			}
		}
	}
	return false
}

func isFallthroughTarget(cgs []*ast.CommentGroup) (int, bool) {
	for _, cg := range cgs {
		for _, c := range cg.List {
			if after, found := strings.CutPrefix(c.Text, "// FALLTHROUGH "); found {
				if max, err := strconv.Atoi(strings.TrimSpace(after)); err == nil {
					return max, true
				}
			}
		}
	}
	return 0, false
}

func isInt(e ast.Expr) bool {
	ident, ok := e.(*ast.Ident)
	if !ok {
		return false
	}
	switch ident.Name {
	case "byte", "rune", "int8", "int16", "int32", "int64", "int", "uint8", "uint16", "uint32", "uint64", "uint":
		return true
	default:
		return false
	}
}

func unwrapCast(e ast.Expr) ast.Expr {
	if ce, ok := e.(*ast.CallExpr); ok && len(ce.Args) == 1 && isInt(ce.Fun) {
		return ce
	}
	return e
}

func litInt(e ast.Expr) (int64, bool) {
	lit, ok := unwrapCast(e).(*ast.BasicLit)
	if !ok {
		return 0, false
	}
	if lit.Kind != token.INT {
		return 0, false
	}
	x, err := strconv.ParseInt(lit.Value, 0, 64)
	if err != nil {
		return 0, false
	}
	return x, true
}

type constantRange struct {
	name string
	init int
	end  int
	step int
	op   token.Token
}

func (cr *constantRange) Init() int {
	return cr.init
}

func (cr *constantRange) End(x int) bool {
	switch cr.op {
	case token.LEQ:
		return !(x <= cr.end)
	case token.LSS:
		return !(x < cr.end)
	case token.GTR:
		return !(x > cr.end)
	case token.GEQ:
		return !(x >= cr.end)
	case token.EQL:
		return !(x == cr.end)
	case token.NEQ:
		return !(x != cr.end)
	default:
		panic("unreachable")
	}
}

func (cr *constantRange) Next(x int) int {
	return x + cr.step
}

var errUnsupportedStyleForStmt = errors.New("unsupported style for-stmt")

func toConstantRange(s *ast.ForStmt) (*constantRange, error) {
	assignStmt, ok := s.Init.(*ast.AssignStmt)
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	if len(assignStmt.Lhs) != 1 || len(assignStmt.Rhs) != 1 {
		return nil, errUnsupportedStyleForStmt
	}
	name := assignStmt.Lhs[0].(*ast.Ident).Name
	init, ok := litInt(assignStmt.Rhs[0])
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	condExpr, ok := s.Cond.(*ast.BinaryExpr)
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	if x, ok := condExpr.X.(*ast.Ident); !ok || x.Name != name {
		return nil, errUnsupportedStyleForStmt
	}
	end, ok := litInt(condExpr.Y)
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	switch condExpr.Op {
	case token.LSS:
	case token.LEQ:
	case token.GTR:
	case token.GEQ:
	case token.EQL:
	case token.NEQ:
	default:
		return nil, errUnsupportedStyleForStmt
	}
	var step int
	switch stmt := s.Post.(type) {
	case *ast.IncDecStmt:
		if stmt.X.(*ast.Ident).Name != name {
			return nil, errUnsupportedStyleForStmt
		}
		if stmt.Tok == token.INC {
			step = 1
		} else {
			step = -1
		}
	case *ast.AssignStmt:
		if len(stmt.Lhs) != 1 || len(stmt.Rhs) != 1 {
			return nil, errUnsupportedStyleForStmt
		}
		if x, ok := stmt.Lhs[0].(*ast.Ident); !ok || x.Name != name {
			return nil, errUnsupportedStyleForStmt
		}
		lit, ok := stmt.Rhs[0].(*ast.BasicLit)
		if !ok || lit.Kind != token.INT {
			return nil, errUnsupportedStyleForStmt
		}
		v, err := strconv.ParseInt(lit.Value, 0, 8)
		if err != nil {
			return nil, err
		}
		switch stmt.Tok {
		case token.ADD_ASSIGN:
			step = int(v)
		case token.SUB_ASSIGN:
			step = int(-v)
		default:
			return nil, errUnsupportedStyleForStmt
		}
	}
	return &constantRange{name: name, init: int(init), op: condExpr.Op, end: int(end), step: step}, nil
}

type dynamicRange struct {
	name    string
	maxName string
	max     int
}

func toDynamicRange(s *ast.ForStmt, max int) (*dynamicRange, error) {
	assignStmt, ok := s.Init.(*ast.AssignStmt)
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	if len(assignStmt.Lhs) != 1 || len(assignStmt.Rhs) != 1 {
		return nil, errUnsupportedStyleForStmt
	}
	name := assignStmt.Lhs[0].(*ast.Ident).Name
	init, ok := litInt(assignStmt.Rhs[0])
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	if init != 0 {
		return nil, errUnsupportedStyleForStmt
	}
	condExpr, ok := s.Cond.(*ast.BinaryExpr)
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	if x, ok := condExpr.X.(*ast.Ident); !ok || x.Name != name {
		return nil, errUnsupportedStyleForStmt
	}
	maxIdent, ok := unwrapCast(condExpr.Y).(*ast.Ident)
	if !ok {
		return nil, errUnsupportedStyleForStmt
	}
	switch condExpr.Op {
	case token.LSS:
	default:
		return nil, errUnsupportedStyleForStmt
	}
	if stmt, ok := s.Post.(*ast.IncDecStmt); !ok || stmt.X.(*ast.Ident).Name != name || stmt.Tok != token.INC {
		return nil, errUnsupportedStyleForStmt
	}
	return &dynamicRange{name: name, maxName: maxIdent.Name, max: max}, nil
}
